#!/usr/bin/env bash

set -euo pipefail

mkdir -p certs

# Fetch and remap CA cert.
kubectl get secret -o yaml $CRDBCLUSTER-ca | yq '.data."ca.key"' | base64 -d >certs/ca.key
kubectl get secret -o yaml $CRDBCLUSTER-node | yq '.data."ca.crt"' | base64 -d >certs/ca.crt
kubectl create configmap $CRDBCLUSTER-ca --from-file=certs/ca.crt --dry-run=client -o yaml |
  kubectl apply -f -

# Fetch and update node certs. The node certs generated by the helm chart don't
# include the necessary SANs for the cloud operator, so we create new certs
# with the existing SANs as well as the additional SANs required for the cloud
# operator.
hosts=()
for host in $(kubectl get secret -o yaml $CRDBCLUSTER-node |
  yq '.data."tls.crt"' |
  base64 -d |
  openssl x509 -noout -ext subjectAltName |
  tail -n+2 |
  sed -E 's/(DNS:)|(IP Address:)|,//g' |
  xargs); do
  hosts+=($host)
done
hosts+=("$CRDBCLUSTER-join.$NAMESPACE.svc.cluster.local")
cockroach cert create-node --ca-key ./certs/ca.key --certs-dir ./certs --overwrite "${hosts[@]}"

kubectl create secret generic $CRDBCLUSTER-node-certs --from-file=tls.crt=certs/node.crt --from-file=tls.key=certs/node.key --dry-run=client -o yaml |
  kubectl apply -f -

# Root user certs. The public operator doesn't generate one, so we create new certs signed by the original CA.
cockroach cert create-client root --ca-key certs/ca.key --certs-dir ./certs --overwrite
kubectl create secret generic $CRDBCLUSTER-client-certs --from-file=tls.crt=./certs/client.root.crt --from-file=tls.key=./certs/client.root.key --dry-run=client -o yaml | kubectl apply -f -
