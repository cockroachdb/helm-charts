#!/usr/bin/env bash

set -euo pipefail

mkdir -p certs
mkdir -p backup

base_chart_name="cockroachdb"
if [[ "$RELEASE_NAME" == *"$base_chart_name"* ]]; then
    export crdb_name="${RELEASE_NAME}"
  else
    export crdb_name="${RELEASE_NAME}-${base_chart_name}"
fi

# Fetch and remap CA cert.
kubectl get secret -o yaml $crdb_name-ca-secret | yq '.data."ca.key"' | base64 -d >certs/ca.key
kubectl get secret -o yaml $crdb_name-ca-secret | yq '.data."ca.crt"' | base64 -d >certs/ca.crt
kubectl create configmap $crdb_name-ca --from-file=certs/ca.crt --dry-run=client -o yaml |
  kubectl apply -f -

# Fetch and update node certs. The node certs generated by the helm chart don't
# include the necessary SANs for the cloud operator, so we create new certs
# with the existing SANs as well as the additional SANs required for the cloud
# operator.
kubectl get secret -o yaml $crdb_name-node-secret >backup/cockroachdb-node-secret.yaml

hosts=()
for host in $(cat backup/cockroachdb-node-secret.yaml |
  yq '.data."tls.crt"' |
  base64 -d |
  openssl x509 -noout -ext subjectAltName |
  tail -n+2 |
  sed -E 's/(DNS:)|(IP Address:)|,//g' |
  xargs); do
  hosts+=($host)
done
hosts+=("$RELEASE_NAME-cockroachdb-join.$NAMESPACE.svc.cluster.local")
cockroach cert create-node --ca-key ./certs/ca.key --certs-dir ./certs --overwrite --lifetime=43732h "${hosts[@]}"

kubectl create secret generic $crdb_name-node-certs --from-file=tls.crt=certs/node.crt --from-file=tls.key=certs/node.key --dry-run=client -o yaml |
  kubectl apply -f -

# Root user certs. The public operator doesn't generate one, so we create new certs signed by the original CA.
cockroach cert create-client root --ca-key certs/ca.key --certs-dir ./certs --lifetime 43732h --overwrite
kubectl create secret generic $crdb_name-client-certs --from-file=tls.crt=./certs/client.root.crt --from-file=tls.key=./certs/client.root.key --dry-run=client -o yaml |
  kubectl apply -f -
