#!/usr/bin/env bash

set -euo pipefail

mkdir -p certs
mkdir -p backup

# Fetch and remap CA cert.
kubectl get secret -o yaml $RELEASE_NAME-cockroachdb-ca-secret | yq '.data."ca.key"' | base64 -d >certs/ca.key
kubectl get secret -o yaml $RELEASE_NAME-cockroachdb-node-secret | yq '.data."ca.crt"' | base64 -d >certs/ca.crt
kubectl create configmap $RELEASE_NAME-cockroachdb-node-ca --from-file=certs/ca.crt
kubectl create configmap $RELEASE_NAME-cockroachdb-client-ca --from-file=certs/ca.crt

# Fetch and update node certs. The node certs generated by the helm chart don't
# include the necessary SANs for the cloud operator, so we create new certs
# with the existing SANs as well as the additional SANs required for the cloud
# operator.
kubectl get secret -o yaml $RELEASE_NAME-cockroachdb-node-secret >backup/cockroachdb-node-secret.yaml

hosts=()
for host in $(cat backup/cockroachdb-node-secret.yaml |
  yq '.data."tls.crt"' |
  base64 -d |
  openssl x509 -noout -ext subjectAltName |
  tail -n+2 |
  sed -E 's/(DNS:)|(IP Address:)|,//g' |
  xargs); do
  hosts+=($host)
done
hosts+=("$RELEASE_NAME-cockroachdb-join.$NAMESPACE.svc.cluster.local")
cockroach cert create-node --ca-key ./certs/ca.key --certs-dir ./certs --overwrite --lifetime=43732h "${hosts[@]}"

kubectl delete secret $RELEASE_NAME-cockroachdb-node-secret
kubectl create secret generic $RELEASE_NAME-cockroachdb-node-secret --from-file=tls.crt=certs/node.crt --from-file=tls.key=certs/node.key

# Root user certs. The public operator doesn't generate one, so we create new certs signed by the original CA.
cockroach cert create-client root --ca-key certs/ca.key --certs-dir ./certs --lifetime 43732h --overwrite
kubectl create secret generic cockroach-client-certs --from-file=tls.crt=./certs/client.root.crt --from-file=tls.key=./certs/client.root.key
